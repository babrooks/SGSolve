// This file is part of the SGSolve library for stochastic games
// Copyright (C) 2019 Benjamin A. Brooks
// 
// SGSolve free software: you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// SGSolve is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see
// <http://www.gnu.org/licenses/>.
// 
// Benjamin A. Brooks
// ben@benjaminbrooks.net
// Chicago, IL

#ifndef _SGSOLUTION_MAXMINMAX_HPP
#define _SGSOLUTION_MAXMINMAX_HPP

#include "sggame.hpp"
#include "sgiteration_maxminmax.hpp"
#include <boost/archive/text_iarchive.hpp>
#include <boost/archive/text_oarchive.hpp>
#include <boost/archive/binary_iarchive.hpp>
#include <boost/archive/binary_oarchive.hpp>
#include <boost/serialization/utility.hpp>

//! Records the progress of SGSolver_MaxMinMax::solve().
/*! This class contains a copy of the game used by SGSolver_MaxMinMax,
    a list of iterations generated by SGSolver_MaxMinMax::solve().
    
    \ingroup src
*/
class SGSolution_MaxMinMax
{
private:
  SGGame game; /*!< The game that was solved. */
  list<SGIteration_MaxMinMax> iterations; /*!< A list of SGIteration_MaxMinMax objects
                                   tracking the progress of
                                   SGSolver::solve(). */
  
public:
  //! Default constructor
  SGSolution_MaxMinMax() {}
  //! Initializes an SGSolution_MaxMinMax object with a copy of the SGGame _game.
  SGSolution_MaxMinMax(const SGGame& _game):
    game(_game)
  {}

  //! Get method for the game
  const SGGame & getGame() const { return game; }
  //! Get method for the iterations
  const list<SGIteration_MaxMinMax> & getIterations() const { return iterations; }
  
  //! Resets the SGSolution_MaxMinMax object by clearing the iterations and
  //! extremeTuples lists.
  void clear() {iterations.clear(); }
  //! Adds a new iteration to the back of SGSolution_MaxMinMax::iterations
  void push_back(const SGIteration_MaxMinMax & iteration)
  { iterations.push_back(iteration); }

  //! Serializes the SGSolution_MaxMinMax object using boost
  template<class Archive>
  void serialize(Archive &ar, const unsigned int version)
  {
    ar & game & iterations;
  }

  //! Static method for saving an SGSolution_MaxMinMax object to the file filename.
  static void save(const SGSolution_MaxMinMax & soln, const char* filename)
  {
    std::ofstream ofs(filename,std::fstream::out);

    if (ofs.good())
      {
	boost::archive::binary_oarchive oa(ofs);
	oa << soln;
      }
    else
      throw(SGException(SG::FAILED_OPEN));

    ofs.close();
  }

  //! Static method for loading an SGSolution_MaxMinMax object from the file filename.
  static void load(SGSolution_MaxMinMax & soln, const char* filename)
  {
    std::ifstream ifs(filename,std::fstream::in);
    if (ifs.good() && ifs.is_open())
      {
	boost::archive::binary_iarchive ia(ifs);
	ia >> soln;
      }
    else
      throw(SGException(SG::FAILED_OPEN));

    ifs.close();
  }

  friend class boost::serialization::access;
}; // SGSolution_MaxMinMax

#endif
