// This file is part of the SGSolve library for stochastic games
// Copyright (C) 2016 Benjamin A. Brooks
// 
// SGSolve free software: you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// SGSolve is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see
// <http://www.gnu.org/licenses/>.
// 
// Benjamin A. Brooks
// ben@benjaminbrooks.net
// Chicago, IL

#ifndef _SGSOLUTION_V2_HPP
#define _SGSOLUTION_V2_HPP

#include "sggame.hpp"
#include "sgiteration_v2.hpp"
#include <boost/archive/text_iarchive.hpp>
#include <boost/archive/text_oarchive.hpp>
#include <boost/serialization/utility.hpp>

//! Records the progress of SGSolver::solve().
/*! This class contains a copy of the game used by SGSolver, a list of
    iterations and a list of extreme tuples generated by
    SGSolver::solve(). 
    
    \ingroup src
*/
class SGSolution_V2
{
private:
  SGGame game; /*!< The game that was solved. */
  list<SGIteration_V2> iterations; /*!< A list of SGIteration_V2 objects
                                   tracking the progress of
                                   SGSolver::solve(). */
  
public:
  //! Default constructor
  SGSolution_V2() {}
  //! Initializes an SGSolution_V2 object with a copy of the SGGame _game.
  SGSolution_V2(const SGGame& _game):
    game(_game)
  {}

  //! Get method for the game
  const SGGame & getGame() const { return game; }
  //! Get method for the iterations
  const list<SGIteration_V2> & getIterations() const { return iterations; }
  
  //! Resets the SGSolution_V2 object by clearing the iterations and
  //! extremeTuples lists.
  void clear() {iterations.clear(); }
  //! Adds a new iteration to the back of SGSolution_V2::iterations
  void push_back(const SGIteration_V2 & iteration)
  { iterations.push_back(iteration); }

  //! Serializes the SGSolution_V2 object using boost
  template<class Archive>
  void serialize(Archive &ar, const unsigned int version)
  {
    ar & game & iterations;
  }

  //! Static method for saving an SGSolution_V2 object to the file filename.
  static void save(const SGSolution_V2 & soln, const char* filename)
  {
    std::ofstream ofs(filename,std::fstream::out);

    if (ofs.good())
      {
	boost::archive::text_oarchive oa(ofs);
	oa << soln;
      }
    else
      throw(SGException(SG::FAILED_OPEN));
  }

  //! Static method for loading an SGSolution_V2 object from the file filename.
  static void load(SGSolution_V2 & soln, const char* filename)
  {
    std::ifstream ifs(filename,std::fstream::in);
    if (ifs.good() && ifs.is_open())
      {
	boost::archive::text_iarchive ia(ifs);
	ia >> soln;
      }
    else
      throw(SGException(SG::FAILED_OPEN));
  }

  friend class boost::serialization::access;
}; // SGSolution_V2

#endif
