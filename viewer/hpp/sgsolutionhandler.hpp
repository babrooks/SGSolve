// This file is part of the SGSolve library for stochastic games
// Copyright (C) 2016 Benjamin A. Brooks
// 
// SGSolve free software: you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// SGSolve is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see
// <http://www.gnu.org/licenses/>.
// 
// Benjamin A. Brooks
// ben@benjaminbrooks.net
// Chicago, IL

#ifndef SGSOLUTIONHANDLER_HPP
#define SGSOLUTIONHANDLER_HPP

#include "sgplotsettings.hpp"
#include "sgsolution.hpp"
#include "sgcustomplot.hpp"
#include "sgsimulationhandler.hpp"
#include "sgplotcontroller.hpp"
#include "sgstatecombomodel.hpp"
#include "sgactioncombomodel.hpp"

//! Handles the widgets for displaying the solution
/*! This class contains all of the widgets on the solution tab for
    displaying the SGSolution generated by the SGSolver. This class
    sets up the widgets for viewing and controlling the view of the
    solution, and it directly implements the plotting routines. The
    specification of what to plot is controlled by a member
    SGPlotController. 

    Specifically, SGSolutionHandler constructs plots for the
    trajectory of the pivot in each state, which are the statePlots,
    and it constructs a detailPlot which shows the behavior of the
    algorithm at a particular iteration or a particular
    equilibrium. 

    There are two modes for the solution. In "Progress" mode, the
    program will display the progress of the algorithm from a starting
    iteration to a final iteration, and the detail plot will show how
    the next direction is selected at the last iteration. The start
    and end are controlled by QScrollBars. By default, detailPlot will
    show the test directions for the best action, but the user can
    display test directions for other actions using QComboBoxes. 

    In "Final" mode, the program just shows the pivots on the last
    revolution, which is basically the true equilibrium payoff
    correspondence.

    The sliders and combo boxes communicate with and are controlled by
    a member SGPlotController object, which aggregates all of the
    user-provided specifications into a compact set of parameters that
    are used by SGSolutionHandler::plotSolution() to construct the
    plots.

    See also \ref viewersolutionsec.

  \ingroup viewer
*/
class SGSolutionHandler : public QObject
{
  Q_OBJECT

private:
  //! Solution
  /*! Stores all of the information related to the result of the
      computation. */
  SGSolution soln;
  //! A pointer to the associated plot controller.
  SGPlotController * controller;

  //! The parent widget, which is an SGMainWindow object.
  QWidget * parent;

  //! A bound on the size of payoffs
  double payoffBound;

  //! True if a solution has been loaded.
  bool solnLoaded;

  // Plots
  //! Left hand plot that shows construction of a point
  SGCustomPlot * detailPlot;
  //! Vector of state plots
  /*! One plot for each state, shows the trajectory of the pivot for
      that state. */
  vector<SGCustomPlot *> statePlots;

  //! Plot settings
  SGPlotSettings plotSettings;

  //! Master layout for the solution handler. 
  QVBoxLayout * layout;
  
  //! Layout holding the state plots.
  QGridLayout * statePlotsLayout;

  //! Action to toggle detailed titles
  QAction * detailedTitlesAction;

  //! Action for equalizing axes
  QAction* equalizeAxesAction;

  //! Pointer to simulation handler
  SGSimulationHandler * simHandler;

  // Methods
  //! Plots the solution from start to end
  void plotSolution();
  //! Plots the solution for a particular state.
  void plotSolution(SGCustomPlot * plot, int state,
		    bool addSquares);
  //! Generates title for the detail plot
  QString generatePlotTitle(int state, int action,bool addIterRev);
  //! Gets bounds for the plots.
  QCPRange getBounds(const QVector<double> & x) const;
  //! Adds a point to the indicated graph in the indicated scatter style
  void addPoint(const SGPoint & point,QCustomPlot* plot,
		const QCPScatterStyle & style);
  //! Converts point,dir into a QCPCurve associated with the given plot
  QCPCurve * vectorToQCPCurve(SGCustomPlot * plot,
			      const SGPoint & point,
			      const SGPoint & dir);
  //! Converts point,dir into a QCPItemLine associated with the given plot
  QCPItemLine * sgToQCPItemLine(SGCustomPlot * plot,
				const SGPoint & point,
				const SGPoint & dir);
public:
  //! Constructor
  /*! Constructs the widgets and the layout, connects signals and
      slots. */
  SGSolutionHandler(QWidget * parent = 0);

  //! Sets the solution to newSoln.
  void setSolution(const SGSolution & newSoln);
  //! Returns a const reference to the solution.
  const SGSolution & getSolution() const
  {return soln;}

  //! Returns the layout
  QVBoxLayout * getLayout() const
  { return layout; }
  
  //! Returns the detailed titles action
  QAction * getDetailedTitlesAction() const
  { return detailedTitlesAction; }
  
  //! Returns the equalize axes action
  QAction * getEqualizeAxesAction() const
  { return equalizeAxesAction; }

  //! Decrements the iteration through the SGPlotController.
  void moveBackwards() { controller->moveBackwards(); }
  //! Increments the iteration through the SGPlotController.
  void moveForwards() { controller->moveForwards(); }

  //! Decrements the action profile through the SGPlotController.
  void prevAction() { emit prevActionSignal(); }
  //! Increments the action profile through the SGPlotController.
  void nextAction() { emit nextActionSignal(); }

signals:
  void nextActionSignal();
  void prevActionSignal();
			 
public slots:
  //! Inspect point slot
  void inspectPoint(SGPoint point,
		    int state, bool isDetailPlot);
  
  //! Simulate equilibrium slot
  void simulateEquilibrium(SGPoint point,
			   int state, bool isDetailPlot);
  //! Replot slot
  void replotSlot() { plotSolution(); }

};

#endif
